esphome:
  name: fossibot-remote-v2
  friendly_name: Fossibot Remote V2
  platformio_options:
    board_build.arduino.memory_type: qio_opi
    board_build.flash_mode: qio
    board_build.psram_type: opi
  on_boot:
    then:
      - lambda: 'id(last_touch_ms) = millis();'

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: arduino

api:
  encryption:
    key: "FYkj/2TxDQMFONe9ykeUvRmfoTY2MfVJay3Pm3fOEd0="

psram:
  mode: octal
  speed: 80MHz

ota:
  platform: esphome
  password: "ea0ae625bf4793e8a6acb3a5f56f0f08"

logger:
  level: DEBUG
  baud_rate: 115200
  hardware_uart: UART0
  logs:
    component: ERROR

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: LIGHT

  ap:
    ssid: "Fossibot-Remote-V2"
    password: "SxWBhL3B0EEE"

captive_portal:

external_components:
  - source: github://dandwhelan/esp-fbot
    refresh: 0s
    components: [ fbot ]

# --- GLOBALS ---
globals:
  - id: ac_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: usb_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: dc_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_touch_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: fossi_menu
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: screen_state
    type: int
    restore_value: no
    initial_value: '2'
  - id: last_tap_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

# --- INTERVALS ---
interval:
  # Pulse animation refresh (10 fps while active)
  - interval: 100ms
    then:
      - if:
          condition:
            lambda: |-
              uint32_t now = millis();
              return (now - id(ac_press_time)  < 1500) ||
                     (now - id(usb_press_time) < 1500) ||
                     (now - id(dc_press_time)  < 1500);
          then:
            - component.update: tft_display

  # Backlight timeout — direct PWM, only fires on state change
  - interval: 5s
    then:
      - lambda: |-
          uint32_t idle = millis() - id(last_touch_ms);
          int target = 2;
          if (idle > 60000) target = 0;
          else if (idle > 30000) target = 1;
          if (target != id(screen_state)) {
            id(screen_state) = target;
            if (target == 0) {
              id(backlight_pwm).set_level(0.0f);
            } else if (target == 1) {
              id(backlight_pwm).set_level(0.15f);
            }
          }

  # Battery LED — smooth red→orange→yellow→green gradient
  - interval: 10s
    then:
      - lambda: |-
          if (!id(fbot_bat).has_state() || !id(fbot_connected).state) {
            auto call = id(status_led).turn_off();
            call.perform();
            return;
          }
          float pct = id(fbot_bat).state / 100.0f;
          float r = pct < 0.5f ? 1.0f : 2.0f * (1.0f - pct);
          float g = pct > 0.5f ? 1.0f : 2.0f * pct;
          auto call = id(status_led).turn_on();
          call.set_brightness(0.15f);
          call.set_rgb(r, g, 0.0f);
          call.perform();

# --- BACKLIGHT PWM OUTPUT ---
output:
  - platform: ledc
    pin: GPIO15
    id: backlight_pwm
    frequency: 1000Hz

# --- LIGHTS ---
light:
  - platform: monochromatic
    output: backlight_pwm
    id: backlight
    name: "Display Backlight"
    default_transition_length: 500ms
    restore_mode: ALWAYS_ON

  - platform: esp32_rmt_led_strip
    id: status_led
    pin: GPIO48
    num_leds: 1
    chipset: WS2812
    rgb_order: GRB
    name: "Battery LED"

# --- HARDWARE: SHARED SPI BUS ---
spi:
  id: bus_a
  clk_pin: GPIO12
  mosi_pin: GPIO11
  miso_pin: GPIO13

# --- HARDWARE: I2C BUS (BME280) ---
i2c:
  sda: GPIO17
  scl: GPIO18
  scan: true

# --- FONTS ---
font:
  - file: "gfonts://Roboto"
    id: font_sm
    size: 16

  - file: "gfonts://Roboto"
    id: font_md
    size: 24

  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_lg
    size: 60

# --- COLORS ---
color:
  - id: c_white
    red: 100%
    green: 100%
    blue: 100%
  - id: c_black
    red: 0%
    green: 0%
    blue: 0%
  - id: c_fossibot_orange
    red: 100%
    green: 60%
    blue: 0%
  - id: c_grid
    red: 30%
    green: 30%
    blue: 30%
  - id: c_green
    red: 0%
    green: 100%
    blue: 0%

# --- HARDWARE: DISPLAY ---
display:
  platform: ili9xxx
  id: tft_display
  model: ILI9341
  spi_id: bus_a
  cs_pin: GPIO10
  dc_pin: GPIO9
  reset_pin: GPIO14
  rotation: 90
  data_rate: 20MHz
  invert_colors: false
  update_interval: 5s

  lambda: |-
    it.fill(id(c_black));

    // =============================================
    //  FOSSIBOT SETTINGS SCREEN
    // =============================================
    if (id(fossi_menu)) {
      // --- Header bar ---
      it.filled_rectangle(0, 0, 320, 24, Color(40, 40, 40));
      it.print(5, 4, id(font_sm), id(c_white), "FOSSIBOT SETTINGS");
      it.print(315, 4, id(font_sm), id(c_fossibot_orange), TextAlign::TOP_RIGHT, "< BACK");
      it.line(0, 24, 320, 24, id(c_grid));

      // --- Toggle button renderer ---
      auto draw_toggle = [&](int x, int y, int w, int h, bool state) {
        Color bg = state ? Color(0, 80, 0) : Color(50, 50, 50);
        Color bc = state ? Color(0, 180, 0) : Color(100, 100, 100);
        Color tc = state ? Color(0, 220, 0) : Color(160, 160, 160);
        it.filled_rectangle(x, y, w, h, bg);
        it.rectangle(x, y, w, h, bc);
        it.print(x + w/2, y + h/2, id(font_sm), tc, TextAlign::CENTER,
                 state ? "ON" : "OFF");
      };

      // --- Nav/adjust button renderer ---
      auto draw_nav = [&](int x, int y, int w, int h, const char* label) {
        it.filled_rectangle(x, y, w, h, Color(40, 40, 80));
        it.rectangle(x, y, w, h, Color(80, 80, 160));
        it.print(x + w/2, y + h/2, id(font_sm), id(c_white), TextAlign::CENTER, label);
      };

      int rh = 30;
      int by = 28;

      // Row 1: KEY SOUND
      it.print(5, by + 7, id(font_sm), id(c_white), "KEY SOUND");
      draw_toggle(220, by + 3, 96, 24, id(sw_key_sound).state);

      // Row 2: SILENT CHG
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "SILENT CHG");
      draw_toggle(220, by + 3, 96, 24, id(sw_ac_silent).state);

      // Row 3: LIGHT
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "LIGHT");
      draw_toggle(220, by + 3, 96, 24, id(sw_light).state);

      // Row 4: LIGHT MODE
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "LIGHT MODE");
      draw_nav(185, by + 3, 30, 24, "<");
      if (id(sel_light_mode).has_state())
        it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
                 TextAlign::TOP_CENTER, id(sel_light_mode).current_option().c_str());
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, ">");

      // Row 5: CHG LIMIT
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "CHG LIMIT");
      draw_nav(185, by + 3, 30, 24, "<");
      if (id(sel_charge_limit).has_state())
        it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
                 TextAlign::TOP_CENTER, id(sel_charge_limit).current_option().c_str());
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, ">");

      // Row 6: CHG THRESH
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "CHG THRESH");
      draw_nav(185, by + 3, 30, 24, "-");
      if (id(num_chg_thresh).has_state())
        it.printf(250, by + 7, id(font_sm), id(c_fossibot_orange),
                  TextAlign::TOP_CENTER, "%d%%", (int)id(num_chg_thresh).state);
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, "+");

      // Row 7: DIS THRESH
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "DIS THRESH");
      draw_nav(185, by + 3, 30, 24, "-");
      if (id(num_dis_thresh).has_state())
        it.printf(250, by + 7, id(font_sm), id(c_fossibot_orange),
                  TextAlign::TOP_CENTER, "%d%%", (int)id(num_dis_thresh).state);
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, "+");

      return;
    }

    // =============================================
    //  TOP STATUS BAR
    // =============================================
    if (id(dashboard_voltage).has_state()) {
      it.printf(5, 2, id(font_sm), id(c_white), "Remote: %.1fV", id(dashboard_voltage).state);
    }

    // --- Temp & Humidity (top right) ---
    if (id(bme_temp).has_state() && id(bme_hum).has_state()) {
      it.printf(315, 2, id(font_sm), id(c_white), TextAlign::TOP_RIGHT,
                "%.0f°C  %.0f%%", id(bme_temp).state, id(bme_hum).state);
    } else {
      it.print(315, 2, id(font_sm), id(c_grid), TextAlign::TOP_RIGHT, "-- --");
    }

    if (!id(fbot_connected).state) {
      it.print(160, 120, id(font_md), id(c_white), TextAlign::CENTER, "Waiting for Fossibot...");
      return;
    }

    // =============================================
    //  MAIN DASHBOARD  (only when BLE is connected)
    // =============================================

    // --- Battery Percentage (centre circle) ---
    it.circle(160, 105, 55, id(c_grid));

    if (id(fbot_bat).has_state()) {
      int bat = (int)id(fbot_bat).state;
      Color bat_color = id(c_white);
      if (bat < 20) bat_color = Color(255, 0, 0);
      it.printf(160, 105, id(font_lg), bat_color, TextAlign::CENTER, "%d%%", bat);
    }

    // --- Power flow (left / right) ---
    it.print(40, 85, id(font_sm), id(c_grid), TextAlign::CENTER, "INPUT");
    if (id(fbot_in).has_state()) {
      it.printf(40, 110, id(font_md), id(c_green), TextAlign::CENTER, "%.0fW", id(fbot_in).state);
    }

    it.print(280, 85, id(font_sm), id(c_grid), TextAlign::CENTER, "OUTPUT");
    if (id(fbot_out).has_state()) {
      it.printf(280, 110, id(font_md), id(c_fossibot_orange), TextAlign::CENTER, "%.0fW", id(fbot_out).state);
    }

    // =============================================
    //  4-BUTTON BAR  (bottom 60 px)
    // =============================================
    uint32_t now = millis();
    int btn_y = 180;
    int btn_h = 60;
    int btn_w = 77;
    int gap   = 4;

    auto calc_pulse = [](uint32_t press_time, uint32_t now_ms) -> float {
      if (press_time == 0) return 0.0f;
      uint32_t elapsed = now_ms - press_time;
      if (elapsed > 1500) return 0.0f;
      float t = (float)elapsed / 1500.0f;
      float decay = 1.0f - t;
      float wave  = (cosf(t * 3.14159f * 6.0f) + 1.0f) / 2.0f;
      return decay * wave;
    };

    auto draw_button = [&](int x, int y, int w, int h,
                           const char* label, bool state, float pulse) {
      if (state) {
        int g = (int)(25 + pulse * 100);
        it.filled_rectangle(x, y, w, h, Color(0, g, 0));
      } else {
        int v = (int)(18 + pulse * 70);
        it.filled_rectangle(x, y, w, h, Color(v, v, v));
      }

      Color bc = state
        ? Color(0, (int)(130 + pulse * 125), 0)
        : Color((int)(55 + pulse * 90), (int)(55 + pulse * 90), (int)(55 + pulse * 90));
      it.rectangle(x, y, w, h, bc);
      if (state) it.rectangle(x + 1, y + 1, w - 2, h - 2, bc);

      Color tc = state
        ? Color(0, (int)(200 + pulse * 55), 0)
        : Color((int)(150 + pulse * 105), (int)(150 + pulse * 105), (int)(150 + pulse * 105));
      it.print(x + w / 2, y + h / 2, id(font_md), tc, TextAlign::CENTER, label);
    };

    float p_ac  = calc_pulse(id(ac_press_time),  now);
    float p_usb = calc_pulse(id(usb_press_time), now);
    float p_dc  = calc_pulse(id(dc_press_time),  now);

    draw_button(0,                 btn_y, btn_w, btn_h, "AC",  id(sw_ac).state,  p_ac);
    draw_button(btn_w + gap,       btn_y, btn_w, btn_h, "USB", id(sw_usb).state, p_usb);
    draw_button(2 * (btn_w + gap), btn_y, btn_w, btn_h, "DC",  id(sw_dc).state,  p_dc);

    // --- FOSSI settings button (orange theme) ---
    int fx = 3 * (btn_w + gap);
    it.filled_rectangle(fx, btn_y, btn_w, btn_h, Color(40, 24, 0));
    it.rectangle(fx, btn_y, btn_w, btn_h, id(c_fossibot_orange));
    it.print(fx + btn_w / 2, btn_y + btn_h / 2, id(font_md),
             id(c_fossibot_orange), TextAlign::CENTER, "SET");

# --- HARDWARE: DEEP SLEEP (power button) ---
deep_sleep:
  id: deep_sleep_ctrl
  wakeup_pin:
    number: GPIO4
    inverted: true
    allow_other_uses: true

# --- HARDWARE: TOUCHSCREEN ---
touchscreen:
  platform: xpt2046
  id: my_touch
  spi_id: bus_a
  cs_pin: GPIO6
  interrupt_pin: GPIO7
  update_interval: 50ms
  threshold: 400
  calibration:
    x_min: 300
    x_max: 3800
    y_min: 200
    y_max: 3700
  transform:
    swap_xy: true
    mirror_x: true
    mirror_y: true
  on_touch:
    - lambda: |-
        uint32_t now = millis();
        id(last_touch_ms) = now;
        if (id(screen_state) == 0) {
          // Screen off: require double-tap to wake
          uint32_t gap = now - id(last_tap_ms);
          if (gap > 100 && gap < 500) {
            id(screen_state) = 2;
            id(backlight_pwm).set_level(1.0f);
            id(last_tap_ms) = 0;
          } else {
            id(last_tap_ms) = now;
          }
        } else if (id(screen_state) == 1) {
          // Dim: single touch wakes
          id(screen_state) = 2;
          id(backlight_pwm).set_level(1.0f);
        }

# --- HARDWARE: BLUETOOTH ---
esp32_ble_tracker:
  scan_parameters:
    interval: 2000ms
    window: 200ms
    duration: 5min
    active: true

ble_client:
  - mac_address: "DC:1E:D5:E4:07:1E"
    id: fossibot_ble

fbot:
  id: my_fbot
  ble_client_id: fossibot_ble
  polling_interval: 5s
  settings_polling_interval: 60s

# --- SENSORS ---
sensor:
  - platform: adc
    pin: GPIO1
    attenuation: 12db
    name: "Dashboard Voltage"
    id: dashboard_voltage
    filters:
      - multiply: 2.0

  - platform: bme280_i2c
    address: 0x76
    update_interval: 30s
    temperature:
      name: "Temperature"
      id: bme_temp
      oversampling: 2x
    humidity:
      name: "Humidity"
      id: bme_hum
      oversampling: 2x
    pressure:
      name: "Pressure"
      id: bme_pres

  - platform: fbot
    fbot_id: my_fbot
    battery_level: { name: "Battery", id: fbot_bat }
    input_power:   { name: "Input",   id: fbot_in }
    output_power:  { name: "Output",  id: fbot_out }

# --- BINARY SENSORS ---
binary_sensor:
  - platform: fbot
    fbot_id: my_fbot
    connected: { name: "Connected", id: fbot_connected }

  # ===== POWER BUTTON (hold 3s to enter deep sleep) =====
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    name: "Power Button"
    id: power_button
    filters:
      - delayed_on: 50ms
    on_click:
      min_length: 3s
      max_length: 10s
      then:
        - lambda: 'id(backlight_pwm).set_level(0.0f);'
        - delay: 100ms
        - deep_sleep.enter: deep_sleep_ctrl

  # ===== MAIN DASHBOARD BUTTONS (gated: screen on + menu closed) =====

  - platform: touchscreen
    name: "Touch AC"
    touchscreen_id: my_touch
    x_min: 0
    x_max: 77
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_ac
              - globals.set:
                  id: ac_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  - platform: touchscreen
    name: "Touch USB"
    touchscreen_id: my_touch
    x_min: 81
    x_max: 158
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_usb
              - globals.set:
                  id: usb_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  - platform: touchscreen
    name: "Touch DC"
    touchscreen_id: my_touch
    x_min: 162
    x_max: 239
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_dc
              - globals.set:
                  id: dc_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  - platform: touchscreen
    name: "Touch FOSSI"
    touchscreen_id: my_touch
    x_min: 243
    x_max: 320
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu);'
            then:
              - globals.set:
                  id: fossi_menu
                  value: 'true'
              - component.update: tft_display

  # ===== SETTINGS MENU BUTTONS (gated: screen on + menu open) =====

  - platform: touchscreen
    name: "Touch Back"
    touchscreen_id: my_touch
    x_min: 220
    x_max: 320
    y_min: 0
    y_max: 24
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - globals.set:
                  id: fossi_menu
                  value: 'false'
              - component.update: tft_display

  # Row 1: KEY SOUND toggle (y = 28+3=31 to 31+24=55)
  - platform: touchscreen
    name: "Touch Key Sound"
    touchscreen_id: my_touch
    x_min: 220
    x_max: 316
    y_min: 31
    y_max: 55
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - switch.toggle: sw_key_sound
              - component.update: tft_display

  # Row 2: SILENT CHG toggle (y = 58+3=61 to 61+24=85)
  - platform: touchscreen
    name: "Touch Silent Chg"
    touchscreen_id: my_touch
    x_min: 220
    x_max: 316
    y_min: 61
    y_max: 85
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - switch.toggle: sw_ac_silent
              - component.update: tft_display

  # Row 3: LIGHT toggle (y = 88+3=91 to 91+24=115)
  - platform: touchscreen
    name: "Touch Light"
    touchscreen_id: my_touch
    x_min: 220
    x_max: 316
    y_min: 91
    y_max: 115
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - switch.toggle: sw_light
              - component.update: tft_display

  # Row 4: LIGHT MODE < (y = 118+3=121 to 121+24=145)
  - platform: touchscreen
    name: "Touch LtMode Prev"
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 121
    y_max: 145
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - select.previous:
                  id: sel_light_mode
                  cycle: true
              - component.update: tft_display

  # Row 4: LIGHT MODE >
  - platform: touchscreen
    name: "Touch LtMode Next"
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 121
    y_max: 145
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - select.next:
                  id: sel_light_mode
                  cycle: true
              - component.update: tft_display

  # Row 5: CHG LIMIT < (y = 148+3=151 to 151+24=175)
  - platform: touchscreen
    name: "Touch ChgLim Prev"
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 151
    y_max: 175
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - select.previous:
                  id: sel_charge_limit
                  cycle: true
              - component.update: tft_display

  # Row 5: CHG LIMIT >
  - platform: touchscreen
    name: "Touch ChgLim Next"
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 151
    y_max: 175
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - select.next:
                  id: sel_charge_limit
                  cycle: true
              - component.update: tft_display

  # Row 6: CHG THRESH - (y = 178+3=181 to 181+24=205)
  - platform: touchscreen
    name: "Touch ChgThr Down"
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 181
    y_max: 205
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_chg_thresh
                  value: !lambda |-
                    float v = id(num_chg_thresh).state - 5.0f;
                    return v < 10.0f ? 10.0f : v;
              - component.update: tft_display

  # Row 6: CHG THRESH +
  - platform: touchscreen
    name: "Touch ChgThr Up"
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 181
    y_max: 205
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_chg_thresh
                  value: !lambda |-
                    float v = id(num_chg_thresh).state + 5.0f;
                    return v > 100.0f ? 100.0f : v;
              - component.update: tft_display

  # Row 7: DIS THRESH - (y = 208+3=211 to 211+24=235)
  - platform: touchscreen
    name: "Touch DisThr Down"
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 211
    y_max: 235
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_dis_thresh
                  value: !lambda |-
                    float v = id(num_dis_thresh).state - 5.0f;
                    return v < 0.0f ? 0.0f : v;
              - component.update: tft_display

  # Row 7: DIS THRESH +
  - platform: touchscreen
    name: "Touch DisThr Up"
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 211
    y_max: 235
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_dis_thresh
                  value: !lambda |-
                    float v = id(num_dis_thresh).state + 5.0f;
                    return v > 50.0f ? 50.0f : v;
              - component.update: tft_display

# --- NUMBER CONTROLS ---
number:
  - platform: fbot
    fbot_id: my_fbot
    threshold_charge:    { name: "Charge Threshold",    id: num_chg_thresh }
    threshold_discharge: { name: "Discharge Threshold", id: num_dis_thresh }

# --- SELECT CONTROLS ---
select:
  - platform: fbot
    fbot_id: my_fbot
    light_mode:      { name: "Light Mode",      id: sel_light_mode }
    ac_charge_limit: { name: "AC Charge Limit", id: sel_charge_limit }

# --- SWITCHES ---
switch:
  - platform: fbot
    fbot_id: my_fbot
    ac:         { name: "AC",               id: sw_ac }
    usb:        { name: "USB",              id: sw_usb }
    dc:         { name: "DC",               id: sw_dc }
    key_sound:  { name: "Key Sound",        id: sw_key_sound }
    light:      { name: "Light",            id: sw_light }
    ac_silent:  { name: "Silent Charging",  id: sw_ac_silent }
