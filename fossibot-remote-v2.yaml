esphome:
  name: fossibot-remote-v2
  friendly_name: Fossibot Remote V2
  platformio_options:
    board_build.arduino.memory_type: qio_opi
    board_build.flash_mode: qio
    board_build.psram_type: opi
  on_boot:
    then:
      - lambda: 'id(last_touch_ms) = millis();'

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: arduino

api:
  encryption:
    key: "FYkj/2TxDQMFONe9ykeUvRmfoTY2MfVJay3Pm3fOEd0="

psram:
  mode: octal
  speed: 80MHz

ota:
  platform: esphome
  password: "ea0ae625bf4793e8a6acb3a5f56f0f08"

logger:
  level: DEBUG
  baud_rate: 115200
  hardware_uart: UART0
  logs:
    component: ERROR

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: LIGHT

  ap:
    ssid: "Fossibot-Remote-V2"
    password: "SxWBhL3B0EEE"

captive_portal:

external_components:
  - source: github://dandwhelan/esp-fbot
    refresh: 0s
    components: [ fbot ]]

# --- GLOBALS ---
globals:
  - id: ac_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: usb_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: dc_press_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_touch_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: fossi_menu
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: screen_state
    type: int
    restore_value: no
    initial_value: '2'
  - id: last_tap_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: ac_timer_mins
    type: int
    restore_value: no
    initial_value: '0'
  - id: dc_timer_mins
    type: int
    restore_value: no
    initial_value: '0'
  - id: idle_timeout_secs
    type: int
    restore_value: no
    initial_value: '60'
  - id: ac_timer_start
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: dc_timer_start
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: settings_tap_count
    type: int
    restore_value: no
    initial_value: '0'
  - id: settings_first_tap_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

# --- INTERVALS ---
interval:
  # Pulse animation refresh (10 fps while active)
  - interval: 100ms
    then:
      - if:
          condition:
            lambda: |-
              uint32_t now = millis();
              return (now - id(ac_press_time)  < 1500) ||
                     (now - id(usb_press_time) < 1500) ||
                     (now - id(dc_press_time)  < 1500);
          then:
            - component.update: tft_display

  # Backlight timeout — driven by idle_timeout_secs setting
  - interval: 5s
    then:
      - lambda: |-
          uint32_t timeout_ms = (uint32_t)id(idle_timeout_secs) * 1000UL;
          if (timeout_ms == 0) return;
          uint32_t idle = millis() - id(last_touch_ms);
          int target = 2;
          if (idle > timeout_ms) target = 0;
          else if (idle > timeout_ms / 2) target = 1;
          if (target != id(screen_state)) {
            id(screen_state) = target;
            if (target == 0) {
              id(backlight_pwm).set_level(0.0f);
            } else if (target == 1) {
              id(backlight_pwm).set_level(0.15f);
            }
          }

  # Timer auto-off check
  - interval: 5s
    then:
      - lambda: |-
          if (!id(fbot_connected).state) return;
          uint32_t now = millis();
          // AC Timer
          if (id(ac_timer_mins) > 0 && id(sw_ac).state) {
            if (id(ac_timer_start) == 0) {
              id(ac_timer_start) = now;
            } else if ((now - id(ac_timer_start)) > (uint32_t)id(ac_timer_mins) * 60000UL) {
              id(sw_ac).turn_off();
              id(ac_timer_start) = 0;
            }
          } else {
            id(ac_timer_start) = 0;
          }
          // DC Timer
          if (id(dc_timer_mins) > 0 && id(sw_dc).state) {
            if (id(dc_timer_start) == 0) {
              id(dc_timer_start) = now;
            } else if ((now - id(dc_timer_start)) > (uint32_t)id(dc_timer_mins) * 60000UL) {
              id(sw_dc).turn_off();
              id(dc_timer_start) = 0;
            }
          } else {
            id(dc_timer_start) = 0;
          }

  # Battery LED — smooth red→orange→yellow→green gradient
  - interval: 10s
    then:
      - lambda: |-
          if (!id(fbot_bat).has_state() || !id(fbot_connected).state) {
            auto call = id(status_led).turn_off();
            call.perform();
            return;
          }
          float pct = id(fbot_bat).state / 100.0f;
          float r = pct < 0.5f ? 1.0f : 2.0f * (1.0f - pct);
          float g = pct > 0.5f ? 1.0f : 2.0f * pct;
          auto call = id(status_led).turn_on();
          call.set_brightness(0.15f);
          call.set_rgb(r, g, 0.0f);
          call.perform();

# --- BACKLIGHT PWM OUTPUT ---
output:
  - platform: ledc
    pin: GPIO15
    id: backlight_pwm
    frequency: 1000Hz

# --- LIGHTS ---
light:
  - platform: monochromatic
    output: backlight_pwm
    id: backlight
    name: "Display Backlight"
    default_transition_length: 500ms
    restore_mode: ALWAYS_ON

  - platform: esp32_rmt_led_strip
    id: status_led
    pin: GPIO48
    num_leds: 1
    chipset: WS2812
    rgb_order: GRB
    name: "Battery LED"

# --- HARDWARE: SHARED SPI BUS ---
spi:
  id: bus_a
  clk_pin: GPIO12
  mosi_pin: GPIO11
  miso_pin: GPIO13

# --- HARDWARE: I2C BUS (BME280) ---
i2c:
  sda: GPIO17
  scl: GPIO18
  scan: true

# --- FONTS ---
font:
  - file: "gfonts://Roboto"
    id: font_sm
    size: 16

  - file: "gfonts://Roboto"
    id: font_md
    size: 24

  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_lg
    size: 60

# --- COLORS ---
color:
  - id: c_white
    red: 100%
    green: 100%
    blue: 100%
  - id: c_black
    red: 0%
    green: 0%
    blue: 0%
  - id: c_fossibot_orange
    red: 100%
    green: 60%
    blue: 0%
  - id: c_grid
    red: 30%
    green: 30%
    blue: 30%
  - id: c_green
    red: 0%
    green: 100%
    blue: 0%

# --- HARDWARE: DISPLAY ---
display:
  platform: ili9xxx
  id: tft_display
  model: ILI9341
  spi_id: bus_a
  cs_pin: GPIO10
  dc_pin: GPIO9
  reset_pin: GPIO14
  rotation: 90
  data_rate: 20MHz
  invert_colors: false
  update_interval: 5s

  lambda: |-
    it.fill(id(c_black));

    // =============================================
    //  FOSSIBOT SETTINGS SCREEN
    // =============================================
    if (id(fossi_menu)) {
      // --- Header bar ---
      it.filled_rectangle(0, 0, 320, 24, Color(40, 40, 40));
      it.print(5, 4, id(font_sm), id(c_white), "FOSSIBOT SETTINGS");
      it.print(315, 4, id(font_sm), id(c_fossibot_orange), TextAlign::TOP_RIGHT, "< BACK");
      it.line(0, 24, 320, 24, id(c_grid));

      // --- Toggle button renderer ---
      auto draw_toggle = [&](int x, int y, int w, int h, bool state) {
        Color bg = state ? Color(0, 80, 0) : Color(50, 50, 50);
        Color bc = state ? Color(0, 180, 0) : Color(100, 100, 100);
        Color tc = state ? Color(0, 220, 0) : Color(160, 160, 160);
        it.filled_rectangle(x, y, w, h, bg);
        it.rectangle(x, y, w, h, bc);
        it.print(x + w/2, y + h/2, id(font_sm), tc, TextAlign::CENTER,
                 state ? "ON" : "OFF");
      };

      // --- Nav/adjust button renderer ---
      auto draw_nav = [&](int x, int y, int w, int h, const char* label) {
        it.filled_rectangle(x, y, w, h, Color(40, 40, 80));
        it.rectangle(x, y, w, h, Color(80, 80, 160));
        it.print(x + w/2, y + h/2, id(font_sm), id(c_white), TextAlign::CENTER, label);
      };

      int rh = 30;
      int by = 28;

      // Row 1: KEY SOUND
      it.print(5, by + 7, id(font_sm), id(c_white), "KEY SOUND");
      draw_toggle(220, by + 3, 96, 24, id(sw_key_sound).state);

      // Row 2: CHG THRESH
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "CHG THRESH");
      draw_nav(185, by + 3, 30, 24, "-");
      if (id(num_chg_thresh).has_state())
        it.printf(250, by + 7, id(font_sm), id(c_fossibot_orange),
                  TextAlign::TOP_CENTER, "%d%%", (int)id(num_chg_thresh).state);
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, "+");

      // Row 3: DIS THRESH
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "DIS THRESH");
      draw_nav(185, by + 3, 30, 24, "-");
      if (id(num_dis_thresh).has_state())
        it.printf(250, by + 7, id(font_sm), id(c_fossibot_orange),
                  TextAlign::TOP_CENTER, "%d%%", (int)id(num_dis_thresh).state);
      else
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      draw_nav(286, by + 3, 30, 24, "+");

      // --- Timer formatting helper ---
      auto fmt_timer = [](int mins, char* buf, size_t sz) {
        if (mins <= 0) { snprintf(buf, sz, "OFF"); return; }
        if (mins < 60) { snprintf(buf, sz, "%dm", mins); return; }
        snprintf(buf, sz, "%dh", mins / 60);
      };
      char tbuf[8];

      // Row 4: AC TIMER
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "AC TIMER");
      draw_nav(185, by + 3, 30, 24, "<");
      fmt_timer(id(ac_timer_mins), tbuf, sizeof(tbuf));
      it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
               TextAlign::TOP_CENTER, tbuf);
      draw_nav(286, by + 3, 30, 24, ">");

      // Row 5: IDLE TIMER (screen timeout)
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "IDLE TIMER");
      draw_nav(185, by + 3, 30, 24, "<");
      {
        char ibuf[8];
        int s = id(idle_timeout_secs);
        if (s <= 0)      snprintf(ibuf, sizeof(ibuf), "NEVER");
        else if (s < 60) snprintf(ibuf, sizeof(ibuf), "%ds", s);
        else             snprintf(ibuf, sizeof(ibuf), "%dm", s / 60);
        it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
                 TextAlign::TOP_CENTER, ibuf);
      }
      draw_nav(286, by + 3, 30, 24, ">");

      // Row 6: DC TIMER
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "DC TIMER");
      draw_nav(185, by + 3, 30, 24, "<");
      fmt_timer(id(dc_timer_mins), tbuf, sizeof(tbuf));
      it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
               TextAlign::TOP_CENTER, tbuf);
      draw_nav(286, by + 3, 30, 24, ">");

      // Row 7: SYS SLEEP (Reg 68 — machine shutdown timer)
      by += rh;
      it.print(5, by + 7, id(font_sm), id(c_white), "SYS SLEEP");
      draw_nav(185, by + 3, 30, 24, "<");
      if (id(num_sleep_timer).has_state()) {
        fmt_timer((int)id(num_sleep_timer).state, tbuf, sizeof(tbuf));
        it.print(250, by + 7, id(font_sm), id(c_fossibot_orange),
                 TextAlign::TOP_CENTER, tbuf);
      } else {
        it.print(250, by + 7, id(font_sm), id(c_grid),
                 TextAlign::TOP_CENTER, "---");
      }
      draw_nav(286, by + 3, 30, 24, ">");

      return;
    }

    // =============================================
    //  TOP STATUS BAR
    // =============================================
    if (id(dashboard_voltage).has_state()) {
      it.printf(5, 2, id(font_sm), id(c_white), "Remote: %.1fV", id(dashboard_voltage).state);
    }

    // --- Temp & Humidity (top right) ---
    if (id(bme_temp).has_state() && id(bme_hum).has_state()) {
      it.printf(315, 2, id(font_sm), id(c_white), TextAlign::TOP_RIGHT,
                "%.0f°C  %.0f%%", id(bme_temp).state, id(bme_hum).state);
    } else {
      it.print(315, 2, id(font_sm), id(c_grid), TextAlign::TOP_RIGHT, "-- --");
    }

    if (!id(fbot_connected).state) {
      it.print(160, 120, id(font_md), id(c_white), TextAlign::CENTER, "Waiting for Fossibot...");
      return;
    }

    // =============================================
    //  MAIN DASHBOARD  (only when BLE is connected)
    // =============================================

    // --- Battery Percentage (centre circle) ---
    it.circle(160, 105, 55, id(c_grid));

    // --- Charge / Discharge time estimate (above battery %) ---
    if (id(fbot_in).has_state() && id(fbot_out).has_state()) {
      float in_w = id(fbot_in).state;
      float out_w = id(fbot_out).state;
      if (in_w > out_w && id(fbot_time_to_full).has_state()) {
        int mins = (int)id(fbot_time_to_full).state;
        if (mins > 0) {
          char tbuf[16];
          if (mins >= 60) snprintf(tbuf, sizeof(tbuf), "CHG %dh %dm", mins / 60, mins % 60);
          else snprintf(tbuf, sizeof(tbuf), "CHG %dm", mins);
          it.print(160, 72, id(font_sm), id(c_green), TextAlign::CENTER, tbuf);
        }
      } else if (out_w > in_w && id(fbot_remaining).has_state()) {
        int mins = (int)id(fbot_remaining).state;
        if (mins > 0) {
          char tbuf[16];
          if (mins >= 60) snprintf(tbuf, sizeof(tbuf), "REM %dh %dm", mins / 60, mins % 60);
          else snprintf(tbuf, sizeof(tbuf), "REM %dm", mins);
          it.print(160, 72, id(font_sm), id(c_fossibot_orange), TextAlign::CENTER, tbuf);
        }
      }
    }

    // --- Battery % (shifted down to make room for time estimate) ---
    if (id(fbot_bat).has_state()) {
      int bat = (int)id(fbot_bat).state;
      Color bat_color = id(c_white);
      if (bat < 20) bat_color = Color(255, 0, 0);
      it.printf(160, 115, id(font_lg), bat_color, TextAlign::CENTER, "%d%%", bat);
    }

    // --- Power flow (left / right) ---
    it.print(40, 85, id(font_sm), id(c_grid), TextAlign::CENTER, "INPUT");
    if (id(fbot_in).has_state()) {
      it.printf(40, 110, id(font_md), id(c_green), TextAlign::CENTER, "%.0fW", id(fbot_in).state);
    }

    it.print(280, 85, id(font_sm), id(c_grid), TextAlign::CENTER, "OUTPUT");
    if (id(fbot_out).has_state()) {
      it.printf(280, 110, id(font_md), id(c_fossibot_orange), TextAlign::CENTER, "%.0fW", id(fbot_out).state);
    }

    // =============================================
    //  3-BUTTON BAR  (bottom 60 px — AC / USB / DC)
    // =============================================
    uint32_t now = millis();
    int btn_y = 180;
    int btn_h = 60;
    int btn_w = 104;
    int gap   = 4;

    auto calc_pulse = [](uint32_t press_time, uint32_t now_ms) -> float {
      if (press_time == 0) return 0.0f;
      uint32_t elapsed = now_ms - press_time;
      if (elapsed > 1500) return 0.0f;
      float t = (float)elapsed / 1500.0f;
      float decay = 1.0f - t;
      float wave  = (cosf(t * 3.14159f * 6.0f) + 1.0f) / 2.0f;
      return decay * wave;
    };

    auto draw_button = [&](int x, int y, int w, int h,
                           const char* label, bool state, float pulse) {
      if (state) {
        int g = (int)(25 + pulse * 100);
        it.filled_rectangle(x, y, w, h, Color(0, g, 0));
      } else {
        int v = (int)(18 + pulse * 70);
        it.filled_rectangle(x, y, w, h, Color(v, v, v));
      }

      Color bc = state
        ? Color(0, (int)(130 + pulse * 125), 0)
        : Color((int)(55 + pulse * 90), (int)(55 + pulse * 90), (int)(55 + pulse * 90));
      it.rectangle(x, y, w, h, bc);
      if (state) it.rectangle(x + 1, y + 1, w - 2, h - 2, bc);

      Color tc = state
        ? Color(0, (int)(200 + pulse * 55), 0)
        : Color((int)(150 + pulse * 105), (int)(150 + pulse * 105), (int)(150 + pulse * 105));
      it.print(x + w / 2, y + h / 2, id(font_md), tc, TextAlign::CENTER, label);
    };

    float p_ac  = calc_pulse(id(ac_press_time),  now);
    float p_usb = calc_pulse(id(usb_press_time), now);
    float p_dc  = calc_pulse(id(dc_press_time),  now);

    draw_button(0,                 btn_y, btn_w, btn_h, "AC",  id(sw_ac).state,  p_ac);
    draw_button(btn_w + gap,       btn_y, btn_w, btn_h, "USB", id(sw_usb).state, p_usb);
    draw_button(2 * (btn_w + gap), btn_y, btn_w, btn_h, "DC",  id(sw_dc).state,  p_dc);

# --- HARDWARE: TOUCHSCREEN ---
touchscreen:
  platform: xpt2046
  id: my_touch
  spi_id: bus_a
  cs_pin: GPIO6
  interrupt_pin: GPIO7
  update_interval: 50ms
  threshold: 400
  calibration:
    x_min: 300
    x_max: 3800
    y_min: 200
    y_max: 3700
  transform:
    swap_xy: true
    mirror_x: true
    mirror_y: true
  on_touch:
    - lambda: |-
        uint32_t now = millis();
        id(last_touch_ms) = now;
        ESP_LOGD("touch", "on_touch: state=%d menu=%d", id(screen_state), (int)id(fossi_menu));
        if (id(screen_state) == 0) {
          // Screen off: require double-tap to wake
          uint32_t gap = now - id(last_tap_ms);
          if (gap > 100 && gap < 500) {
            id(screen_state) = 2;
            id(backlight_pwm).set_level(1.0f);
            id(last_tap_ms) = 0;
          } else {
            id(last_tap_ms) = now;
          }
        } else if (id(screen_state) == 1) {
          // Dim: single touch wakes
          id(screen_state) = 2;
          id(backlight_pwm).set_level(1.0f);
        }

# --- HARDWARE: BLUETOOTH ---
esp32_ble_tracker:
  scan_parameters:
    interval: 2000ms
    window: 200ms
    duration: 5min
    active: true

ble_client:
  - mac_address: "DC:1E:D5:E4:07:1E"
    id: fossibot_ble

fbot:
  id: my_fbot
  ble_client_id: fossibot_ble
  polling_interval: 5s
  settings_polling_interval: 60s

# --- SENSORS ---
sensor:
  - platform: adc
    pin: GPIO1
    attenuation: 12db
    name: "Dashboard Voltage"
    id: dashboard_voltage
    filters:
      - multiply: 2.0

  - platform: bme280_i2c
    address: 0x76
    update_interval: 30s
    temperature:
      name: "Temperature"
      id: bme_temp
      oversampling: 2x
    humidity:
      name: "Humidity"
      id: bme_hum
      oversampling: 2x
    pressure:
      name: "Pressure"
      id: bme_pres

  - platform: fbot
    fbot_id: my_fbot
    battery_level:   { name: "Battery",        id: fbot_bat }
    input_power:     { name: "Input",          id: fbot_in }
    output_power:    { name: "Output",         id: fbot_out }
    time_to_full:    { name: "Time to Full",   id: fbot_time_to_full }
    remaining_time:  { name: "Remaining Time", id: fbot_remaining }

# --- BINARY SENSORS ---
binary_sensor:
  - platform: fbot
    fbot_id: my_fbot
    connected: { name: "Connected", id: fbot_connected }

  # ===== 4-TAP SETTINGS GESTURE (top-left corner, hidden) =====
  - platform: touchscreen
    name: "Touch Settings Gesture"
    internal: true
    touchscreen_id: my_touch
    x_min: 0
    x_max: 90
    y_min: 0
    y_max: 30
    on_press:
      then:
        - lambda: |-
            if (id(screen_state) != 2 || id(fossi_menu)) return;
            uint32_t now = millis();
            if (now - id(settings_first_tap_ms) > 2000) {
              id(settings_tap_count) = 1;
              id(settings_first_tap_ms) = now;
            } else {
              id(settings_tap_count) = id(settings_tap_count) + 1;
            }
            ESP_LOGD("touch", "Settings gesture: tap %d", id(settings_tap_count));
            if (id(settings_tap_count) >= 4) {
              id(fossi_menu) = true;
              id(settings_tap_count) = 0;
              id(settings_first_tap_ms) = 0;
              id(tft_display).update();
            }

  # ===== MAIN DASHBOARD BUTTONS (gated: screen on + menu closed) =====

  - platform: touchscreen
    name: "Touch AC"
    internal: true
    touchscreen_id: my_touch
    x_min: 0
    x_max: 104
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_ac
              - globals.set:
                  id: ac_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  - platform: touchscreen
    name: "Touch USB"
    internal: true
    touchscreen_id: my_touch
    x_min: 108
    x_max: 212
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_usb
              - globals.set:
                  id: usb_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  - platform: touchscreen
    name: "Touch DC"
    internal: true
    touchscreen_id: my_touch
    x_min: 216
    x_max: 320
    y_min: 180
    y_max: 240
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && !id(fossi_menu) && id(fbot_connected).state;'
            then:
              - switch.toggle: sw_dc
              - globals.set:
                  id: dc_press_time
                  value: !lambda 'return millis();'
              - component.update: tft_display

  # ===== SETTINGS MENU BUTTONS (gated: screen on + menu open) =====

  - platform: touchscreen
    name: "Touch Back"
    internal: true
    touchscreen_id: my_touch
    x_min: 220
    x_max: 320
    y_min: 0
    y_max: 24
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - globals.set:
                  id: fossi_menu
                  value: 'false'
              - component.update: tft_display

  # Row 1: KEY SOUND toggle (y = 28+3=31 to 31+24=55)
  - platform: touchscreen
    name: "Touch Key Sound"
    internal: true
    touchscreen_id: my_touch
    x_min: 220
    x_max: 316
    y_min: 31
    y_max: 55
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - switch.toggle: sw_key_sound
              - component.update: tft_display

  # Row 2: CHG THRESH - (y = 58+3=61 to 61+24=85)
  - platform: touchscreen
    name: "Touch ChgThr Down"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 61
    y_max: 85
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_chg_thresh
                  value: !lambda |-
                    float v = id(num_chg_thresh).state - 5.0f;
                    return v < 10.0f ? 10.0f : v;
              - component.update: tft_display

  # Row 2: CHG THRESH +
  - platform: touchscreen
    name: "Touch ChgThr Up"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 61
    y_max: 85
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_chg_thresh
                  value: !lambda |-
                    float v = id(num_chg_thresh).state + 5.0f;
                    return v > 100.0f ? 100.0f : v;
              - component.update: tft_display

  # Row 3: DIS THRESH - (y = 88+3=91 to 91+24=115)
  - platform: touchscreen
    name: "Touch DisThr Down"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 91
    y_max: 115
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_dis_thresh
                  value: !lambda |-
                    float v = id(num_dis_thresh).state - 5.0f;
                    return v < 0.0f ? 0.0f : v;
              - component.update: tft_display

  # Row 3: DIS THRESH +
  - platform: touchscreen
    name: "Touch DisThr Up"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 91
    y_max: 115
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - number.set:
                  id: num_dis_thresh
                  value: !lambda |-
                    float v = id(num_dis_thresh).state + 5.0f;
                    return v > 50.0f ? 50.0f : v;
              - component.update: tft_display

  # Row 4: AC TIMER < (y = 118+3=121 to 121+24=145)
  - platform: touchscreen
    name: "Touch AcTimer Prev"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 121
    y_max: 145
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(ac_timer_mins);
                  const int p[] = {0, 30, 60, 120, 240, 480};
                  int v = 480;
                  for (int i = 1; i < 6; i++) { if (p[i] == c) { v = p[i-1]; break; } }
                  id(ac_timer_mins) = v;
                  id(ac_timer_start) = 0;
              - component.update: tft_display

  # Row 4: AC TIMER >
  - platform: touchscreen
    name: "Touch AcTimer Next"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 121
    y_max: 145
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(ac_timer_mins);
                  const int p[] = {0, 30, 60, 120, 240, 480};
                  int v = 0;
                  for (int i = 0; i < 5; i++) { if (p[i] == c) { v = p[i+1]; break; } }
                  id(ac_timer_mins) = v;
                  id(ac_timer_start) = 0;
              - component.update: tft_display

  # Row 5: IDLE TIMER < (y = 148+3=151 to 151+24=175)
  - platform: touchscreen
    name: "Touch IdleTmr Prev"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 151
    y_max: 175
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(idle_timeout_secs);
                  const int p[] = {0, 30, 60, 120, 300, 600};
                  int v = 600;
                  for (int i = 1; i < 6; i++) { if (p[i] == c) { v = p[i-1]; break; } }
                  id(idle_timeout_secs) = v;
              - component.update: tft_display

  # Row 5: IDLE TIMER >
  - platform: touchscreen
    name: "Touch IdleTmr Next"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 151
    y_max: 175
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(idle_timeout_secs);
                  const int p[] = {0, 30, 60, 120, 300, 600};
                  int v = 0;
                  for (int i = 0; i < 5; i++) { if (p[i] == c) { v = p[i+1]; break; } }
                  id(idle_timeout_secs) = v;
              - component.update: tft_display

  # Row 6: DC TIMER < (y = 178+3=181 to 181+24=205)
  - platform: touchscreen
    name: "Touch DcTimer Prev"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 181
    y_max: 205
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(dc_timer_mins);
                  const int p[] = {0, 30, 60, 120, 240, 480};
                  int v = 480;
                  for (int i = 1; i < 6; i++) { if (p[i] == c) { v = p[i-1]; break; } }
                  id(dc_timer_mins) = v;
                  id(dc_timer_start) = 0;
              - component.update: tft_display

  # Row 6: DC TIMER >
  - platform: touchscreen
    name: "Touch DcTimer Next"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 181
    y_max: 205
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu);'
            then:
              - lambda: |-
                  int c = id(dc_timer_mins);
                  const int p[] = {0, 30, 60, 120, 240, 480};
                  int v = 0;
                  for (int i = 0; i < 5; i++) { if (p[i] == c) { v = p[i+1]; break; } }
                  id(dc_timer_mins) = v;
                  id(dc_timer_start) = 0;
              - component.update: tft_display

  # Row 7: SYS SLEEP < (y = 208+3=211 to 211+24=235)
  - platform: touchscreen
    name: "Touch SysSleep Prev"
    internal: true
    touchscreen_id: my_touch
    x_min: 185
    x_max: 215
    y_min: 211
    y_max: 235
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu) && id(num_sleep_timer).has_state();'
            then:
              - lambda: |-
                  int c = (int)id(num_sleep_timer).state;
                  const int p[] = {5, 10, 30, 480};
                  int v = 480;
                  for (int i = 1; i < 4; i++) { if (p[i] == c) { v = p[i-1]; break; } }
                  auto call = id(num_sleep_timer).make_call();
                  call.set_value((float)v);
                  call.perform();
              - component.update: tft_display

  # Row 7: SYS SLEEP >
  - platform: touchscreen
    name: "Touch SysSleep Next"
    internal: true
    touchscreen_id: my_touch
    x_min: 286
    x_max: 316
    y_min: 211
    y_max: 235
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(screen_state) == 2 && id(fossi_menu) && id(num_sleep_timer).has_state();'
            then:
              - lambda: |-
                  int c = (int)id(num_sleep_timer).state;
                  const int p[] = {5, 10, 30, 480};
                  int v = 5;
                  for (int i = 0; i < 3; i++) { if (p[i] == c) { v = p[i+1]; break; } }
                  auto call = id(num_sleep_timer).make_call();
                  call.set_value((float)v);
                  call.perform();
              - component.update: tft_display

# --- NUMBER CONTROLS ---
number:
  - platform: fbot
    fbot_id: my_fbot
    threshold_charge:    { name: "Charge Threshold",    id: num_chg_thresh }
    threshold_discharge: { name: "Discharge Threshold", id: num_dis_thresh }
    sleep_timer:         { name: "Sleep Timer",         id: num_sleep_timer }

# --- SELECT CONTROLS ---
select:
  - platform: fbot
    fbot_id: my_fbot
    light_mode:      { name: "Light Mode",      id: sel_light_mode }
    ac_charge_limit: { name: "AC Charge Limit", id: sel_charge_limit }

# --- SWITCHES ---
switch:
  - platform: fbot
    fbot_id: my_fbot
    ac:         { name: "AC",               id: sw_ac }
    usb:        { name: "USB",              id: sw_usb }
    dc:         { name: "DC",               id: sw_dc }
    key_sound:  { name: "Key Sound",        id: sw_key_sound }
    light:      { name: "Light",            id: sw_light }
    ac_silent:  { name: "Silent Charging",  id: sw_ac_silent }
